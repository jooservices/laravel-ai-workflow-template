# Database Migrations Guide

Complete guide to database migration standards, naming conventions, rollback strategies, and best practices.

> **Related Documentation:**
> - [Repository Pattern](../architecture/flow.md#3-repository---database-access-only) - Database access layer
> - [Performance by Design](../architecture/principles.md#performance-by-design) - Indexing requirements
> - [Standards Reference](../reference/standards.md) - Quick lookup for rules

---

## Overview

Migrations are version control for your database schema. They enable:
- **Reproducible schema changes** across environments
- **Safe rollbacks** when issues are discovered
- **Collaborative development** without manual schema sync
- **Production deployment** confidence

---

## Migration Naming Conventions

### File Naming Pattern

**Format:** `YYYY_MM_DD_HHMMSS_<action>_<table_name>_<optional_description>.php`

**Rules:**
- ✅ **MUST:** Use timestamp prefix (auto-generated by Laravel)
- ✅ **MUST:** Use snake_case for all parts
- ✅ **MUST:** Use descriptive action verbs (`create`, `add`, `modify`, `remove`, `rename`)
- ✅ **MUST:** Include table name after action
- ✅ **SHOULD:** Add description for complex migrations

**Examples:**
```php
// ✅ GOOD
2025_01_15_120000_create_users_table.php
2025_01_15_120001_add_email_verification_to_users_table.php
2025_01_15_120002_create_product_categories_table.php
2025_01_15_120003_add_foreign_key_constraints_to_products_table.php
2025_01_15_120004_rename_status_column_in_orders_table.php

// ❌ WRONG
2025_01_15_120000_users.php                    // Missing action
2025_01_15_120000_createUsers.php              // camelCase (wrong)
2025_01_15_120000_create_users.php             // Missing .php extension in file name
create_users_table.php                         // Missing timestamp
```

### Class Naming Pattern

**Format:** `{Action}{TableName}Table` (PascalCase)

**Rules:**
- ✅ **MUST:** Match file name (Laravel auto-generates from file name)
- ✅ **MUST:** Use PascalCase for class name
- ✅ **MUST:** Use descriptive action verbs

**Examples:**
```php
// ✅ GOOD
final class CreateUsersTable extends Migration {}
final class AddEmailVerificationToUsersTable extends Migration {}
final class CreateProductCategoriesTable extends Migration {}

// ❌ WRONG
final class UsersTable extends Migration {}              // Missing action
final class create_users_table extends Migration {}      // Wrong case
```

---

## Migration Structure

### Standard Migration Template

```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('table_name', function (Blueprint $table) {
            // Schema definition
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('table_name');
    }
};
```

### MANDATORY Requirements

- ✅ **MUST:** Include `declare(strict_types=1);` at top of file
- ✅ **MUST:** Always implement `down()` method for rollback
- ✅ **MUST:** Use `Schema::dropIfExists()` in `down()` (safer than `drop()`)
- ✅ **MUST:** Use anonymous class syntax (`return new class extends Migration`)
- ✅ **MUST:** Use `final` keyword for named classes (if not using anonymous class)

---

## Column Definitions

### Standard Column Types

```php
$table->id();                          // Auto-incrementing primary key (bigint, unsigned)
$table->uuid('uuid')->primary();       // UUID primary key (string, 36 chars)
$table->string('name');                // VARCHAR(255)
$table->string('email', 100);          // VARCHAR(100)
$table->text('description');           // TEXT
$table->integer('count');              // INTEGER
$table->bigInteger('amount');          // BIGINT
$table->decimal('price', 10, 2);       // DECIMAL(10, 2)
$table->boolean('is_active');          // BOOLEAN/TINYINT(1)
$table->date('birth_date');            // DATE
$table->dateTime('created_at');        // DATETIME
$table->timestamp('updated_at');       // TIMESTAMP
$table->json('metadata');              // JSON
$table->enum('status', ['active', 'inactive']);  // ENUM
```

### Column Modifiers

```php
$table->string('email')->nullable();           // NULL allowed
$table->string('email')->unique();             // Unique constraint
$table->string('email')->index();              // Add index
$table->integer('order')->default(0);          // Default value
$table->string('slug')->unique()->index();     // Multiple modifiers
$table->text('content')->after('title');       // Column position (MySQL only)
$table->timestamp('deleted_at')->nullable();   // Soft delete
```

---

## Table Operations

### Create Table

```php
public function up(): void
{
    Schema::create('products', function (Blueprint $table) {
        $table->uuid('uuid')->primary();
        $table->string('name');
        $table->text('description')->nullable();
        $table->decimal('price', 10, 2);
        $table->boolean('is_active')->default(true);
        $table->timestamps();
        $table->softDeletes();
        
        // Indexes
        $table->index('name');
        $table->index(['is_active', 'created_at']);
    });
}

public function down(): void
{
    Schema::dropIfExists('products');
}
```

### Add Column

```php
public function up(): void
{
    Schema::table('users', function (Blueprint $table) {
        $table->string('phone')->nullable()->after('email');
        $table->boolean('is_verified')->default(false)->after('phone');
    });
}

public function down(): void
{
    Schema::table('users', function (Blueprint $table) {
        $table->dropColumn(['phone', 'is_verified']);
    });
}
```

### Modify Column

```php
public function up(): void
{
    Schema::table('products', function (Blueprint $table) {
        $table->string('name', 500)->change();  // Increase length
        $table->decimal('price', 12, 2)->nullable()->change();  // Make nullable
    });
}

public function down(): void
{
    Schema::table('products', function (Blueprint $table) {
        $table->string('name')->change();
        $table->decimal('price', 10, 2)->change();
    });
}
```

### Rename Column

```php
public function up(): void
{
    Schema::table('users', function (Blueprint $table) {
        $table->renameColumn('email_address', 'email');
    });
}

public function down(): void
{
    Schema::table('users', function (Blueprint $table) {
        $table->renameColumn('email', 'email_address');
    });
}
```

### Drop Column

```php
public function up(): void
{
    Schema::table('users', function (Blueprint $table) {
        $table->dropColumn('phone');
    });
}

public function down(): void
{
    Schema::table('users', function (Blueprint $table) {
        $table->string('phone')->nullable();
    });
}
```

---

## Indexes

### Index Naming Conventions

**Format:** `{table}_{column(s)}_{type}_index`

**Types:**
- `_index` - Standard index
- `_unique_index` - Unique index
- `_foreign_index` - Foreign key index (auto-generated)

**Rules:**
- ✅ **MUST:** Use snake_case
- ✅ **MUST:** Include table name prefix
- ✅ **MUST:** List columns in order (composite indexes)
- ✅ **MUST:** Include type suffix

**Examples:**
```php
// ✅ GOOD (auto-generated names)
$table->index('name');                          // products_name_index
$table->unique('email');                        // users_email_unique_index
$table->index(['category_id', 'status']);       // products_category_id_status_index

// ✅ GOOD (explicit names)
$table->index('name', 'products_name_index');
$table->unique(['email', 'deleted_at'], 'users_email_deleted_at_unique_index');
```

### Index Best Practices

```php
// ✅ Add indexes for frequently queried columns
$table->index('status');
$table->index('created_at');

// ✅ Composite indexes for multi-column queries
$table->index(['category_id', 'status', 'created_at']);

// ✅ Unique indexes for uniqueness constraints
$table->unique('email');

// ✅ Partial unique indexes (soft deletes)
$table->unique(['email', 'deleted_at']);  // Unique when deleted_at is NULL

// ❌ DON'T over-index (slows down writes)
// Only index columns used in WHERE, ORDER BY, or JOIN clauses
```

---

## Foreign Key Constraints

### Adding Foreign Keys

```php
public function up(): void
{
    Schema::table('products', function (Blueprint $table) {
        $table->foreignUuid('category_id')
            ->constrained('categories', 'uuid')
            ->onDelete('cascade')
            ->onUpdate('cascade');
    });
}

public function down(): void
{
    Schema::table('products', function (Blueprint $table) {
        $table->dropForeign(['category_id']);
        $table->dropColumn('category_id');
    });
}
```

### Foreign Key Options

```php
// ✅ CASCADE: Delete/update related records
$table->foreign('user_id')
    ->references('id')
    ->on('users')
    ->onDelete('cascade')    // Delete products when user deleted
    ->onUpdate('cascade');   // Update products.user_id when users.id updated

// ✅ RESTRICT: Prevent delete/update if related records exist
$table->foreign('category_id')
    ->references('id')
    ->on('categories')
    ->onDelete('restrict')   // Prevent category deletion if products exist
    ->onUpdate('restrict');

// ✅ SET NULL: Set foreign key to NULL when parent deleted
$table->foreign('parent_id')
    ->references('id')
    ->on('categories')
    ->onDelete('set null')   // Set parent_id = NULL when parent deleted
    ->nullable();

// ❌ NO ACTION: Similar to RESTRICT (default)
```

### Foreign Key Naming

**Auto-generated:** `{table}_{column}_foreign`

**Example:**
```php
// Auto-generated name: products_category_id_foreign
$table->foreign('category_id')->references('id')->on('categories');
```

---

## Timestamps and Soft Deletes

### Standard Timestamps

```php
// ✅ Laravel standard timestamps
$table->timestamps();        // created_at, updated_at (nullable)

// ✅ Custom timestamp names
$table->timestamp('published_at')->nullable();
$table->timestamp('archived_at')->nullable();
```

### Soft Deletes

```php
// ✅ Add soft delete column
$table->softDeletes();       // deleted_at (nullable timestamp)

// ✅ In down() method
$table->dropSoftDeletes();   // Remove soft delete column
```

### UUID Primary Keys (Recommended)

```php
// ✅ UUID primary key pattern
$table->uuid('uuid')->primary();
$table->string('id')->nullable();  // Optional: Keep numeric ID for backward compatibility

// Migration for existing tables
public function up(): void
{
    Schema::table('users', function (Blueprint $table) {
        $table->uuid('uuid')->unique()->after('id');
    });
}
```

---

## Data Migrations

### When to Use Data Migrations

**Use data migrations for:**
- ✅ Transforming existing data (e.g., splitting columns, merging tables)
- ✅ Backfilling new columns with calculated values
- ✅ Data cleanup or normalization
- ✅ Seeding required reference data

**Rules:**
- ✅ **MUST:** Make data migrations idempotent (safe to run multiple times)
- ✅ **MUST:** Handle missing data gracefully
- ✅ **MUST:** Use transactions for data safety
- ✅ **SHOULD:** Log data migration progress

### Data Migration Template

```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        if (!Schema::hasTable('users')) {
            return;  // Safe if table doesn't exist
        }

        DB::transaction(function () {
            // Transform data
            DB::table('users')
                ->whereNull('email_verified_at')
                ->update([
                    'email_verified_at' => DB::raw('created_at'),
                ]);
        });
    }

    public function down(): void
    {
        // Revert data transformation if possible
        DB::transaction(function () {
            DB::table('users')
                ->whereNotNull('email_verified_at')
                ->where('email_verified_at', DB::raw('created_at'))
                ->update([
                    'email_verified_at' => null,
                ]);
        });
    }
};
```

### Data Migration Best Practices

```php
// ✅ Check table/column existence before modifying
if (!Schema::hasTable('users')) {
    return;
}

if (!Schema::hasColumn('users', 'phone')) {
    return;
}

// ✅ Use transactions for data safety
DB::transaction(function () {
    // Data operations
});

// ✅ Batch processing for large datasets
DB::table('users')->chunkById(1000, function ($users) {
    foreach ($users as $user) {
        // Process each user
    }
});

// ✅ Log progress
\Log::info('Data migration started', ['table' => 'users']);
\Log::info('Data migration completed', ['rows_processed' => $count]);
```

---

## Rollback Strategies

### Complete Rollback

**Always implement `down()` method:**
```php
public function down(): void
{
    Schema::dropIfExists('products');
}
```

### Partial Rollback

**Rollback in reverse order:**
```php
// Migration 1: Create table
public function down(): void
{
    Schema::dropIfExists('products');
}

// Migration 2: Add column
public function down(): void
{
    Schema::table('products', function (Blueprint $table) {
        $table->dropColumn('description');
    });
}

// Migration 3: Add index
public function down(): void
{
    Schema::table('products', function (Blueprint $table) {
        $table->dropIndex('products_name_index');
    });
}
```

### Rollback Best Practices

- ✅ **MUST:** Test rollback before deploying
- ✅ **MUST:** Keep `down()` method simple and safe
- ✅ **SHOULD:** Avoid data loss in rollbacks (backup first)
- ✅ **SHOULD:** Document irreversible changes in migration comments

---

## Migration Ordering

### Timestamp-Based Ordering

Laravel automatically orders migrations by timestamp prefix:
- `2025_01_15_120000_create_users_table.php`
- `2025_01_15_120001_create_products_table.php`
- `2025_01_15_120002_add_foreign_key_constraints.php`

### Dependencies

**Handle dependencies explicitly:**
```php
// Migration 1: Create categories table
// Migration 2: Create products table (depends on categories)

// In products migration
public function up(): void
{
    Schema::create('products', function (Blueprint $table) {
        // Ensure categories table exists (check in down() if needed)
        $table->foreignUuid('category_id')
            ->constrained('categories', 'uuid');
    });
}
```

---

## Migration Best Practices

### DO

- ✅ **Always test migrations** on local/staging before production
- ✅ **Use transactions** for data migrations (if supported by database)
- ✅ **Make migrations idempotent** (safe to run multiple times)
- ✅ **Add indexes** for frequently queried columns
- ✅ **Use foreign keys** for data integrity
- ✅ **Keep migrations small** and focused (one logical change per migration)
- ✅ **Document complex migrations** with comments

### DON'T

- ❌ **Don't modify existing migrations** after they've been deployed
- ❌ **Don't add data seeding** in schema migrations (use seeders)
- ❌ **Don't use migrations** for application configuration
- ❌ **Don't delete migrations** from version control
- ❌ **Don't commit migrations** that fail on fresh database

---

## Common Patterns

### Create Table with UUID Primary Key

```php
public function up(): void
{
    Schema::create('products', function (Blueprint $table) {
        $table->uuid('uuid')->primary();
        $table->string('name');
        $table->timestamps();
        $table->softDeletes();
        
        $table->index('name');
    });
}
```

### Create Table with Relationships

```php
public function up(): void
{
    Schema::create('products', function (Blueprint $table) {
        $table->uuid('uuid')->primary();
        $table->foreignUuid('category_id')->constrained('categories', 'uuid');
        $table->string('name');
        $table->timestamps();
        
        $table->index(['category_id', 'created_at']);
    });
}
```

### Add Column with Default

```php
public function up(): void
{
    Schema::table('users', function (Blueprint $table) {
        $table->boolean('is_active')->default(true)->after('email');
    });
}
```

---

## Module Migrations

### Module Migration Location

**Path:** `Modules/{ModuleName}/Database/Migrations/`

**Example:**
```
Modules/Product/Database/Migrations/
├── 2025_01_15_120000_create_products_table.php
├── 2025_01_15_120001_create_product_categories_table.php
└── 2025_01_15_120002_add_foreign_keys_to_products_table.php
```

### Running Module Migrations

```bash
# Run all migrations (including modules)
php artisan migrate

# Run specific module migrations
php artisan migrate --path=Modules/Product/Database/Migrations
```

---

## Troubleshooting

### Common Issues

**Issue:** Migration fails on fresh database
```bash
# Solution: Reset database and re-run
php artisan migrate:fresh
```

**Issue:** Migration rollback fails
```bash
# Solution: Check down() method implementation
# Ensure it's the exact reverse of up()
```

**Issue:** Foreign key constraint fails
```bash
# Solution: Check that referenced table/column exists
# Ensure migrations run in correct order
```

---

## Summary Checklist

### Before Creating Migration

- [ ] Check existing migrations for similar changes
- [ ] Plan rollback strategy
- [ ] Consider data migration needs

### Creating Migration

- [ ] Use correct naming convention
- [ ] Include `declare(strict_types=1);`
- [ ] Implement `down()` method
- [ ] Add necessary indexes
- [ ] Add foreign key constraints
- [ ] Test on fresh database

### Before Deploying

- [ ] Test migration on staging
- [ ] Test rollback on staging
- [ ] Review migration for performance impact
- [ ] Document any special considerations

---

> **Related Documentation:**
> - [Repository Pattern](../architecture/flow.md#3-repository---database-access-only) - Database access layer
> - [Performance by Design](../architecture/principles.md#performance-by-design) - Indexing requirements
> - [Standards Reference](../reference/standards.md) - Quick lookup for rules

